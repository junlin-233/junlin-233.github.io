[{"content":"基础项 比较\n== 只比较值，不比较类型\n=== 除了比较值，也比较类型\n0 == false: bool(true)\r0 === false: bool(false)\r输出\necho - 可以输出一个或多个字符串\nprint- 只允许输出一个字符串，返回值总为 1\n数组\narray() 函数用于创建数组\n1 2 3 4 \u0026lt;?php $cars=array(\u0026#34;Hello\u0026#34;,\u0026#34;CTF\u0026#34;); echo \u0026#34;I like \u0026#34; . $cars[0] . \u0026#34; \u0026#34; . $cars[1] . \u0026#34;.\u0026#34;; ?\u0026gt; 魔术常量\n行如 __FILE__ 这样的 __XXX__ 预定义常量，被称为魔术常量。\n1 2 __FILE__ //返回文件的完整路径和文件名 highlight_file(__FILE__); //代码高亮的显示当前文件内容 表单数据\n$_GET —— 接受 GET 请求传递的参数。\n示例: example.com/index.php?book=HELLOCTF，你可以使用 $_GET['book'] 来获取相应的值。\n$_POST —— 接受 POST 请求传递的参数。\n示例：对 example.com/index.php 进行 POST 传参，参数名为 book 内容为 HelloCTF，你可以使用 $_POST['book'] 来获取相应的值。\n$_REQUEST —— 接受 GET 和 POST 以及 Cookie 请求传递的参数。 示例：\n如果你通过 URL 传递了一个参数 example.com/index.php?key=value_from_get，你可以通过$_REQUEST['key'] 获取这个值。\n如果你通过 POST 方法提交了一个表单，其中有一个名为 key 的字段且其值为value_from_post，你也可以通过 $_REQUEST['key'] 获取这个值。\n同时，如果你设置了一个名为 key 的 cookie，其值为 value_from_cookie，你还是可以使用 $_REQUEST[\u0026lsquo;key\u0026rsquo;] 来获取这个值。\n懒人必备^o^/\n函数\n一般来说名字≈功能，所以理解大于记忆\nassert() : 用于调试，检查一个条件是否为 true。\nunserialize() : 将一个已序列化的字符串转换回 PHP 的值。例如: $array = unserialize($serializedStr) 可以将一个序列化的数组字符串转换为数组。\nmysql_query(): 发送一个 MySQL 查询。\n函数安全 常见绕过\n1 2 3 4 5 6 7 \u0026lt;?php $a = $_GET[\u0026#39;a\u0026#39;]; if (is_numeric($a)) { exit(); } elseif ($a == 404) { echo \u0026#34;flag\u0026#34;; } 想要绕过可以在数字前面或者后面加上 %0a %0b %0c %0d %09\n例如: $a=\u0026quot;404%0a\u0026quot;\n弱类型比较\nstrcmp()\n当 strcmp 比较出错后，会返回 null，null 则为 0 。\n1 2 3 4 5 6 $flag = \u0026#39;flag{123}\u0026#39;; if (strcmp($flag, $_GET[\u0026#39;str\u0026#39;]) == 0) { echo $flag; }else{ echo \u0026#34;Out!\u0026#34;; } 为了使 strcmp 比较出错，可以传入一个数组\nPayload: ?str[]\nis_switch()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $a = \u0026#34;233a\u0026#34;; $flag = \u0026#34;flag{Give you FLAG}\u0026#34;; switch ($a) { case 1: echo \u0026#34;No Flag\u0026#34;; break; case 2: echo \u0026#34;No Flag\u0026#34;; break; case 233: echo $flag; break; default: $a = 233; echo \u0026#34;Haha...\u0026#34;; } case 会自动将字符转换成数值,即遇到非数字就停止\nmd5()\nmd5 在处理哈希字符串的时候，如果 md5 编码后的哈希值时 0e （科学计数法）开头的，都一律解释为 0\n例如:\n1 2 3 4 5 6 7 8 $flag = \u0026#34;flag{THIS_IS_REAL_FLAG}\u0026#34;; $v1 = $_GET[\u0026#39;gat\u0026#39;]; $v2 = $_GET[\u0026#39;tag\u0026#39;]; if ($v1 != $v2 \u0026amp;\u0026amp; md5($v1) == md5($v2)) { echo $flag; }else{ echo \u0026#34;Out!\u0026#34;; } 此时找到两个不相同但md5编码后以0e开头的字符串即可\n如果是这样:\n1 2 3 4 5 6 $flag = \u0026#34;flag{THIS_IS_REAL_FLAG}\u0026#34;; $str1 = $_GET[\u0026#39;gat\u0026#39;]; $str2 = $_GET[\u0026#39;tag\u0026#39;]; if (md5($str1) === md5($str2)) { echo $flag; } 用上述 0e 方法自然是不可行的（注意：=== ），这时候就得使用数组来绕过了，如果传入一个数组的值，会报出错误（md5 只能使用字符串），报错后就相当于绕过 === 这个条件了\n注: 在 PHP 8.0.0 时，该方法行不通了\n如果遇到不能传入数组，只能传入字符串的时候，如下例\n1 2 3 4 5 6 7 8 $flag = \u0026#34;flag{THIS_IS_REAL_FLAG}\u0026#34;; $str1 = $_GET[\u0026#34;gat\u0026#34;]; $str2 = $_GET[\u0026#34;tag\u0026#34;]; if((string)$str1 !== (string)$str2 \u0026amp;\u0026amp; md5($str1)===md5($str2)){ echo \u0026#34;flag{THIS_IS_REAL_FLAG}\u0026#34;; }else{ echo \u0026#34;Out!\u0026#34;; } 这时候就得需要 md5 碰撞，上面判断条件的意思是，str1 和 str2 内容必须不同，但是 md5 必须相同(详细方法待整理)\nsha1()\nsha1 的参数不能为数组，传入数组会返回 NULL\n1 2 3 4 5 6 7 8 9 $flag = \u0026#34;flag{Chain!}\u0026#34;; $get = $_GET[\u0026#39;get\u0026#39;]; $teg = $_GET[\u0026#39;teg\u0026#39;]; if ($get != $teg \u0026amp;\u0026amp; sha1($get) === sha1($teg)) { #if ($get != $teg \u0026amp;\u0026amp; sha1($get) == sha1($teg)) { echo $flag; }else{ echo \u0026#39;Out!\u0026#39;; } Payload: ?get[]=\u0026amp;teg[]=1\n变量覆盖漏洞\n环境得先开启\nregister_globals=ON //此时传递的参数会自动注册为全局变量\r最简单的一种就是我们传入参数例如 ?id=1 把原来id的值给替换\n$$\n类似于c++的指针,例如:\n1 2 3 4 5 6 7 8 9 10 11 $a = \u0026#34;A\u0026#34;; # $b = \u0026#34;B\u0026#34;; # echo $a . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $b . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; foreach ($_GET as $key =\u0026gt; $value) { $$key = $value; } echo $a . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $b . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $key . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $$key . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; 传入\n?a=I'm A\u0026amp;b=I'm B 后,得到\nA\rB\rI'm A\rI'm B\rb\rI'm B\r这里使用了 foreach 来遍历数组的值,遍历 I'm B 到这一项,后面的代码表示把数组的键名b赋值给key,数组的键值赋值给value,并且key可以指向value\n就当成指针理解吧[]`(￣▽￣)\u0026rsquo;*\nextract()\n描述：extract(array,flags,prefix)\n功能​：将数组元素动态转换为变量，常用于处理表单数据（如 $_POST、$_GET）或配置数组。\nflags: 可选，控制冲突处理方式（默认 EXTR_OVERWRITE) 常用值：\nEXTR_OVERWRITE：如果有冲突,覆盖已有变量 EXTR_SKIP：跳过冲突 EXTR_PREFIX_ALL：如果有冲突,为所有变量添加前缀 prefix: 可选，仅在指定flags为前缀模式时有效，用于生成变量名前缀。\nparse_str()\n描述：parse_str(str) 用于将字符串解析成多个变量，没有返回值。简而言之,就是你输入(\u0026ldquo;a=1\u0026amp;b=2\u0026rdquo;)它会自动地生成a,b两个变量\n伪协议\nphp://filter\nphp://filter/read or write=/resource=数据流\rresource=\u0026lt; 要过滤的数据流\u0026gt; （必须） 它指定了你要筛选过滤的数据流\nread和write可选对应对筛选列表的操作\n常用过滤器convert.base64\n编码 convert.base64-encode 解码 convert.base64-decode 例如\nphp://filter/read=convert.base64-encode/resource=files.txt\r更多的可以看P神的谈一谈php://filter的妙用\nphp://input\n如果 html 表单编码设置为\u0026quot;multipart/form-data\u0026quot;,请求是无效的。 一般在 CTF 中用于执行 php 代码（一般在bp里使用）\n需要在php 中设置 allow_url_include = On\nzip:// \u0026amp; bzip2 \u0026amp; zlib://\n需要:\nallow_url_fopen: on\nallow_url_include: on\nzip的一般格式:\nzip://[压缩文件绝对路径]%23[压缩文件内的子文件名]（#编码为%23）\rfile://\n和zip一样需要打开_url_,用于访问本地文件系统，在 CTF 中通常用来读取本地文件\n本文参考资料:Hello CTF (其实就是摘抄啦o(￣▽￣)ブ)\n","date":"2025-05-07T00:00:00Z","permalink":"https://example.com/p/php/","title":"php"},{"content":"关于变量 常量\n1 2 3 4 5 const typename var = val; 声明常量 char * const p 表示指针 p 指向的位置不能改变，但是指向的内容（一个 char）可以改变 const char *p 表示指针 p 指向的内容不能改变，但是指向的位置可以改变 char const *p 同理等价 const char * const p p 指向的位置和内容都不能修改 动态内存\n使用 new 分配，创建对象，返回指针\n1 2 3 T *p = new T[N] 分配 N 个 T 类型的对象，返回指向第一个对象的指针 delete p 释放 p 指向的内存 p 本身不会变为 NULL delete[] p 释放 p 指向的内存 关于类 -C++ 中 class 和 struct 并无本质区别，只是默认的访问权限不同（class 默认 private，struct 默认 public）\n-:: 称为域解析器（resolver），前面什么都不带则解析到自由变量 / 函数（即全局作用域内）\n-成员函数直接在类内部定义的话默认为 inline（不推荐）\n权限有三种：\npublic：公有 private：私有（只有同类可以访问） 注意边界是类不是对象，成员函数中可以访问同一类的其他对象的私有成员 protected：保护（只有同类和子类可以访问） 构造函数\n命名与类名完全相同\n构造函数名称必须与类名一致，无返回值（包括 void）。\n自动调用\n对象创建时由编译器自动调用，无需显式调用。\n可重载\n支持多个构造函数，通过参数列表（类型、数量、顺序）区分。\n访问控制\n可设为 public、protected 或 private，影响对象创建方式（如单例模式）。\n语法\n以冒号 : 开头，后跟成员变量及其初始化表达式：\n1 2 3 4 5 6 7 class Student { public: Student(int id, const string\u0026amp; name) : studentId(id), studentName(name) {} private: const int studentId; // 必须使用初始化列表 string studentName; }; 必要性\n对const成员、引用成员、无默认构造函数的类成员必须使用初始化列表。 提高性能：避免先默认初始化再赋值的额外开销。 ","date":"2025-05-06T00:00:00Z","permalink":"https://example.com/p/test-chinese/","title":"C++面向对象"},{"content":"","date":"2025-05-06T00:00:00Z","permalink":"https://example.com/p/%E4%BB%8A%E5%A4%A9%E6%88%91%E7%9A%84blog%E8%AF%9E%E7%94%9F%E4%BA%86/","title":"今天，我的blog诞生了"}]