[{"content":"[HCTF 2018]WarmUp1(php) 一道php绕过的题目，比较吃代码审计（对我来说≡(▔﹏▔)≡）\n进入网页，F12发现有个source.php\n点进去一串php代码，这里直接给上注释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(\u0026amp;$page) { $whitelist = [\u0026#34;source\u0026#34;=\u0026gt;\u0026#34;source.php\u0026#34;,\u0026#34;hint\u0026#34;=\u0026gt;\u0026#34;hint.php\u0026#34;]; //白名单 if (! isset($page) || !is_string($page)) { //空参的话就返回false echo \u0026#34;you can\u0026#39;t see it\u0026#34;; return false; } if (in_array($page, $whitelist)) { //判断是否在白名单 return true; } $_page = mb_substr( //截取网址0到?的部分 $page, 0, mb_strpos($page . \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); //解码一次，暂时不知道有什么用 $_page = mb_substr( $_page, 0, mb_strpos($_page . \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;) ); if (in_array($_page, $whitelist)) { return true; } echo \u0026#34;you can\u0026#39;t see it\u0026#34;; return false; } } if (! empty($_REQUEST[\u0026#39;file\u0026#39;]) \u0026amp;\u0026amp; is_string($_REQUEST[\u0026#39;file\u0026#39;]) \u0026amp;\u0026amp; emmm::checkFile($_REQUEST[\u0026#39;file\u0026#39;]) ) { include $_REQUEST[\u0026#39;file\u0026#39;]; exit; } else { echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;img src=\\\u0026#34;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\u0026#34; /\u0026gt;\u0026#34;; } ?\u0026gt; 根据代码想要得到flag参数就要满足非空，字符串，和checkFile，前面两个天然满足\n这里注意到还有一个hint.php,访问一下\n得到这样一句话\n那么可以确定flag在/ffffllllaaaagggg目录下\n根据已有的信息试了一下 ?file=source.php?/ffffllllaaaagggg ，没有结果，猜测在子目录下\n又试了试 ?file=source.php?/../../../../ffffllllaaaagggg\n成功了\nPS:这道题比较迷的一点就是解码后这一段（26~36）貌似没什么用\n原题\n","date":"2025-05-08T00:00:00Z","image":"https://example.com/p/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE%E7%9A%84wp/jJSW57nesemLLWA.thumb.1000_0_hu_91ab9986d6a6e2bd.jpg","permalink":"https://example.com/p/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE%E7%9A%84wp/","title":"一些题目的wp"},{"content":"基础项 比较\n== 只比较值，不比较类型\n=== 除了比较值，也比较类型\n0 == false: bool(true)\r0 === false: bool(false)\r输出\necho - 可以输出一个或多个字符串\nprint- 只允许输出一个字符串，返回值总为 1\n数组\narray() 函数用于创建数组\n1 2 3 4 \u0026lt;?php $cars=array(\u0026#34;Hello\u0026#34;,\u0026#34;CTF\u0026#34;); echo \u0026#34;I like \u0026#34; . $cars[0] . \u0026#34; \u0026#34; . $cars[1] . \u0026#34;.\u0026#34;; ?\u0026gt; 魔术常量\n行如 __FILE__ 这样的 __XXX__ 预定义常量，被称为魔术常量。\n1 2 __FILE__ //返回文件的完整路径和文件名 highlight_file(__FILE__); //代码高亮的显示当前文件内容 表单数据\n$_GET —— 接受 GET 请求传递的参数。\n示例: example.com/index.php?book=HELLOCTF，你可以使用 $_GET['book'] 来获取相应的值。\n$_POST —— 接受 POST 请求传递的参数。\n示例：对 example.com/index.php 进行 POST 传参，参数名为 book 内容为 HelloCTF，你可以使用 $_POST['book'] 来获取相应的值。\n$_REQUEST —— 接受 GET 和 POST 以及 Cookie 请求传递的参数。 示例：\n如果你通过 URL 传递了一个参数 example.com/index.php?key=value_from_get，你可以通过$_REQUEST['key'] 获取这个值。\n如果你通过 POST 方法提交了一个表单，其中有一个名为 key 的字段且其值为value_from_post，你也可以通过 $_REQUEST['key'] 获取这个值。\n同时，如果你设置了一个名为 key 的 cookie，其值为 value_from_cookie，你还是可以使用 $_REQUEST[\u0026lsquo;key\u0026rsquo;] 来获取这个值。\n懒人必备^o^/\n函数\n一般来说名字≈功能，所以理解大于记忆\nassert() : 用于调试，检查一个条件是否为 true。\nunserialize() : 将一个已序列化的字符串转换回 PHP 的值。例如: $array = unserialize($serializedStr) 可以将一个序列化的数组字符串转换为数组。\nmysql_query(): 发送一个 MySQL 查询。\n函数安全 常见绕过\n1 2 3 4 5 6 7 \u0026lt;?php $a = $_GET[\u0026#39;a\u0026#39;]; if (is_numeric($a)) { exit(); } elseif ($a == 404) { echo \u0026#34;flag\u0026#34;; } 想要绕过可以在数字前面或者后面加上 %0a %0b %0c %0d %09\n例如: $a=\u0026quot;404%0a\u0026quot;\n弱类型比较\nstrcmp()\n当 strcmp 比较出错后，会返回 null，null 则为 0 。\n1 2 3 4 5 6 $flag = \u0026#39;flag{123}\u0026#39;; if (strcmp($flag, $_GET[\u0026#39;str\u0026#39;]) == 0) { echo $flag; }else{ echo \u0026#34;Out!\u0026#34;; } 为了使 strcmp 比较出错，可以传入一个数组\nPayload: ?str[]\nis_switch()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $a = \u0026#34;233a\u0026#34;; $flag = \u0026#34;flag{Give you FLAG}\u0026#34;; switch ($a) { case 1: echo \u0026#34;No Flag\u0026#34;; break; case 2: echo \u0026#34;No Flag\u0026#34;; break; case 233: echo $flag; break; default: $a = 233; echo \u0026#34;Haha...\u0026#34;; } case 会自动将字符转换成数值,即遇到非数字就停止\nmd5()\nmd5 在处理哈希字符串的时候，如果 md5 编码后的哈希值时 0e （科学计数法）开头的，都一律解释为 0\n例如:\n1 2 3 4 5 6 7 8 $flag = \u0026#34;flag{THIS_IS_REAL_FLAG}\u0026#34;; $v1 = $_GET[\u0026#39;gat\u0026#39;]; $v2 = $_GET[\u0026#39;tag\u0026#39;]; if ($v1 != $v2 \u0026amp;\u0026amp; md5($v1) == md5($v2)) { echo $flag; }else{ echo \u0026#34;Out!\u0026#34;; } 此时找到两个不相同但md5编码后以0e开头的字符串即可\n如果是这样:\n1 2 3 4 5 6 $flag = \u0026#34;flag{THIS_IS_REAL_FLAG}\u0026#34;; $str1 = $_GET[\u0026#39;gat\u0026#39;]; $str2 = $_GET[\u0026#39;tag\u0026#39;]; if (md5($str1) === md5($str2)) { echo $flag; } 用上述 0e 方法自然是不可行的（注意：=== ），这时候就得使用数组来绕过了，如果传入一个数组的值，会报出错误（md5 只能使用字符串），报错后就相当于绕过 === 这个条件了\n注: 在 PHP 8.0.0 时，该方法行不通了\n如果遇到不能传入数组，只能传入字符串的时候，如下例\n1 2 3 4 5 6 7 8 $flag = \u0026#34;flag{THIS_IS_REAL_FLAG}\u0026#34;; $str1 = $_GET[\u0026#34;gat\u0026#34;]; $str2 = $_GET[\u0026#34;tag\u0026#34;]; if((string)$str1 !== (string)$str2 \u0026amp;\u0026amp; md5($str1)===md5($str2)){ echo \u0026#34;flag{THIS_IS_REAL_FLAG}\u0026#34;; }else{ echo \u0026#34;Out!\u0026#34;; } 这时候就得需要 md5 碰撞，上面判断条件的意思是，str1 和 str2 内容必须不同，但是 md5 必须相同(详细方法待整理)\nsha1()\nsha1 的参数不能为数组，传入数组会返回 NULL\n1 2 3 4 5 6 7 8 9 $flag = \u0026#34;flag{Chain!}\u0026#34;; $get = $_GET[\u0026#39;get\u0026#39;]; $teg = $_GET[\u0026#39;teg\u0026#39;]; if ($get != $teg \u0026amp;\u0026amp; sha1($get) === sha1($teg)) { #if ($get != $teg \u0026amp;\u0026amp; sha1($get) == sha1($teg)) { echo $flag; }else{ echo \u0026#39;Out!\u0026#39;; } Payload: ?get[]=\u0026amp;teg[]=1\n变量覆盖漏洞\n环境得先开启\nregister_globals=ON //此时传递的参数会自动注册为全局变量\r最简单的一种就是我们传入参数例如 ?id=1 把原来id的值给替换\n$$\n类似于c++的指针,例如:\n1 2 3 4 5 6 7 8 9 10 11 $a = \u0026#34;A\u0026#34;; # $b = \u0026#34;B\u0026#34;; # echo $a . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $b . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; foreach ($_GET as $key =\u0026gt; $value) { $$key = $value; } echo $a . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $b . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $key . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $$key . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; 传入\n?a=I'm A\u0026amp;b=I'm B 后,得到\nA\rB\rI'm A\rI'm B\rb\rI'm B\r这里使用了 foreach 来遍历数组的值,遍历 I'm B 到这一项,后面的代码表示把数组的键名b赋值给key,数组的键值赋值给value,并且key可以指向value\n就当成指针理解吧[]`(￣▽￣)\u0026rsquo;*\nextract()\n描述：extract(array,flags,prefix)\n功能​：将数组元素动态转换为变量，常用于处理表单数据（如 $_POST、$_GET）或配置数组。\nflags: 可选，控制冲突处理方式（默认 EXTR_OVERWRITE) 常用值：\nEXTR_OVERWRITE：如果有冲突,覆盖已有变量 EXTR_SKIP：跳过冲突 EXTR_PREFIX_ALL：如果有冲突,为所有变量添加前缀 prefix: 可选，仅在指定flags为前缀模式时有效，用于生成变量名前缀。\nparse_str()\n描述：parse_str(str) 用于将字符串解析成多个变量，没有返回值。简而言之,就是你输入(\u0026ldquo;a=1\u0026amp;b=2\u0026rdquo;)它会自动地生成a,b两个变量\n伪协议\nphp://filter\nphp://filter/read or write=/resource=数据流\rresource=\u0026lt; 要过滤的数据流\u0026gt; （必须） 它指定了你要筛选过滤的数据流\nread和write可选对应对筛选列表的操作\n常用过滤器convert.base64\n编码 convert.base64-encode 解码 convert.base64-decode 例如\nphp://filter/read=convert.base64-encode/resource=files.txt\r更多的可以看P神的谈一谈php://filter的妙用\nphp://input\n如果 html 表单编码设置为\u0026quot;multipart/form-data\u0026quot;,请求是无效的。 一般在 CTF 中用于执行 php 代码（一般在bp里使用）\n需要在php 中设置 allow_url_include = On\nzip:// \u0026amp; bzip2 \u0026amp; zlib://\n需要:\nallow_url_fopen: on\nallow_url_include: on\nzip的一般格式:\nzip://[压缩文件绝对路径]%23[压缩文件内的子文件名]（#编码为%23）\rfile://\n和zip一样需要打开_url_,用于访问本地文件系统，在 CTF 中通常用来读取本地文件\n序列化及反序列化 序列化 是将 PHP 对象转换为字符串的过程，可以使用 serialize() 函数来实现。该函数将对象的状态以及它的类名和属性值编码为一个字符串。序列化后的字符串可以存储在文件中，存储在数据库中，或者通过网络传输到其他地方。\n反序列化 是将序列化后的字符串转换回 PHP 对象的过程，可以使用 unserialize() 函数来实现。该函数会将序列化的字符串解码，并将其转换回原始的 PHP 对象。\n普通对象注意 protected 和 private 类型的变量中都加入了不可见字符：\n如果是 protected 变量，则会在变量名前加上 \\x00*\\x00\n如果是 private 变量，则会在变量名前加上 \\x00类名\n一般我们在输出的时候都会先编码后输出\n自定义类时，例如：\n1 2 3 4 5 6 7 public function serialize() { return serialize([ \u0026#39;name\u0026#39; =\u0026gt; $this-\u0026gt;name, \u0026#39;email\u0026#39; =\u0026gt; $this-\u0026gt;email, \u0026#39;phoneNumber\u0026#39; =\u0026gt; $this-\u0026gt;phoneNumber, ]); } 此时输出的格式如图：\nby hello ctf\n其它一些标识，一般都是英文首字母\nb:boolean bool 值\nC:custom object 自定义对象序列化\nd:double 小数\ni:integer 整数\nO:Object 对象\nr:reference 对象引用 \u0026amp;\u0026amp; R:pointer reference 指针引用\nS:encoded string\nN:null NULL 值\n魔术方法\n在 PHP 的序列化中，魔术方法（Magic Methods）是一组特殊的方法，这些方法以双下划线（__）作为前缀，可以在特定的序列化阶段触发从而使开发者能够进一步的控制 序列化 / 反序列化 的过程。\n一般在题目中常见的几个方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 __wakeup() //------ 执行unserialize()时，先会调用这个函数 __sleep() //------- 执行serialize()时，先会调用这个函数，只能返回数组 __construct() //------- 适合在使用对象之前做一些初始化工作 __destruct() //---- 某个对象的所有引用都被删除或者当对象被显式销毁时执行 __call() //-------- 在对象上下文中调用不可访问的方法时触发 __callStatic() //-- 在静态上下文中调用不可访问的方法时触发 __get() //--------- 用于从不可访问的属性读取数据或者不存在这个键都会调用此法 __set() //--------- 用于将数据写入不可访问的属性 __isset() //------- 在不可访问的属性上调用isset()或empty()触发 __unset() //------- 在不可访问的属性上使用unset()时触发 __toString() //---- 把类当作字符串使用时触发 __invoke() //------ 当尝试将对象调用为函数时触发 详细可参考：PHP:魔术方法 - Manual\n属性重载\n在给不可访问（protected 或 private）或不存在的属性赋值时，__set() 会被调用。 读取不可访问（protected 或 private）或不存在的属性的值时，__get() 会被调用。 当对不可访问（protected 或 private）或不存在的属性调用 isset() 或 empty() 时，__isset() 会被调用。 当对不可访问（protected 或 private）或不存在的属性调用 unset() 时，__unset() 会被调用。 详细可参考：PHP:重载 - Manual\n本文参考资料:Hello CTF (其实就是摘抄啦)\n","date":"2025-05-07T00:00:00Z","permalink":"https://example.com/p/php/","title":"php"},{"content":"关于变量 常量\n1 2 3 4 5 const typename var = val; 声明常量 char * const p 表示指针 p 指向的位置不能改变，但是指向的内容（一个 char）可以改变 const char *p 表示指针 p 指向的内容不能改变，但是指向的位置可以改变 char const *p 同理等价 const char * const p p 指向的位置和内容都不能修改 动态内存\n使用 new 分配，创建对象，返回指针\n1 2 3 T *p = new T[N] 分配 N 个 T 类型的对象，返回指向第一个对象的指针 delete p 释放 p 指向的内存 p 本身不会变为 NULL delete[] p 释放 p 指向的内存 关于类 -C++ 中 class 和 struct 并无本质区别，只是默认的访问权限不同（class 默认 private，struct 默认 public）\n-:: 称为域解析器（resolver），前面什么都不带则解析到自由变量 / 函数（即全局作用域内）\n-成员函数直接在类内部定义的话默认为 inline（不推荐）\n权限有三种：\npublic：公有 private：私有（只有同类可以访问） 注意边界是类不是对象，成员函数中可以访问同一类的其他对象的私有成员 protected：保护（只有同类和子类可以访问） 构造函数\n命名与类名完全相同\n构造函数名称必须与类名一致，无返回值（包括 void）。\n自动调用\n对象创建时由编译器自动调用，无需显式调用。\n可重载\n支持多个构造函数，通过参数列表（类型、数量、顺序）区分。\n访问控制\n可设为 public、protected 或 private，影响对象创建方式（如单例模式）。\n语法\n以冒号 : 开头，后跟成员变量及其初始化表达式：\n1 2 3 4 5 6 7 class Student { public: Student(int id, const string\u0026amp; name) : studentId(id), studentName(name) {} private: const int studentId; // 必须使用初始化列表 string studentName; }; 必要性\n对const成员、引用成员、无默认构造函数的类成员必须使用初始化列表。 提高性能：避免先默认初始化再赋值的额外开销。 ","date":"2025-05-06T00:00:00Z","permalink":"https://example.com/p/test-chinese/","title":"C++面向对象"},{"content":"","date":"2025-05-06T00:00:00Z","permalink":"https://example.com/p/%E4%BB%8A%E5%A4%A9%E6%88%91%E7%9A%84blog%E8%AF%9E%E7%94%9F%E4%BA%86/","title":"今天，我的blog诞生了"}]